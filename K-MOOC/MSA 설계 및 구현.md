# MSA 설계 및 구현

## 1주차

### 민첩한 비즈니스를 위해 필요한 시스템의 조건
+ Amazon, Netflix 같은 기업 -> 기존 서비스 + 온라인 기술 = 새로운 서비스 창출, 끊임없는 비즈니스 변화를 통한 새로운 가치 창출 
+ 고객에게빠른 서비스 제공, 피드백 기반의 서비스 개선 및 런칭 -> 시스템 배포 주기와 같이 시스템도 비즈 변화에 빠른 대응 조건 갖춰야함
+ 타임 세일 서비스 시작 -> 과도한 트랙픽 -> Scale Up필요 -> 전체 서비스 Scale Up 불필요 -> 타임 세일 서비스만 Scale Up 가능 하다면 효율적 -> MSA
+ 인프라가 가변적으로 쉽게 변경되는 클라우드 환경 -> 수평 확장을 위한 가장 효율적인 시스템 유형 -> MSA
+ 기업의 민첩한 비즈니스 대응을 위해서 MSA 기반의 시스템이 필요 -> 클라우드 네이티브 어플리케이션

### 마이크로서비스 개념과 모노리식 시스템과의 비교
+ 서로 다른 언어와 데이터 저장기술 사용 가능 -> 폴리그랏(Polyglot): 인터페이스 만족 시 서비스 안의 기술은 자율적으로 선택할 수 있음

### MSA가 주는 주요 특징
+ 비즈니스 역량 기반 팀
+ 프로젝트가 아니라 제품
    + Agile 개발 방식
+ 분권 거버넌스
+ 서비스를 통한 컴포넌트 화
+ 똑똑한 끝지점 단순한 파이프
+ 실패를 위한 설계
    + 실패를 감지하고 대응하기 위한 실시간 모니터링 체계 필요
    + 서킷 브레이크 패턴 -> 각각의 서비스를 모니터링하고 있다가 하나의 서비스가 다운되거나 실패되면 이를 호출하는 서비스의 연계를 차단하고 이에 적절한 대응을 하기 위해 만드는 것
+ 진화하는 설계
+ 분권 데이터 관리
    + 데이터 일관성 문제: 주문과 배송 같이 동시적 Transaction 발생시 문제
    + Eventual Transaction: 특정 시점에 불일치 했던 데이터가 결국에는 일관성을 확보
    + 보통 Event Queue를 써서 해결
+ 인프라 자동화
    + Smart Endpoints and Dump Pipes 선호
        + Domain Logic은 서비스 속에서 높은 응집성 유지 -> 각각의 서비스 연결은 느슨함
        + Rest와 같은 단순한 도구 선호

## 2주차
### 소프트웨어 아키텍처
+ 고려사항: 성능, 가용성, 보안, 유지보수성, 확장성
+ MSA -> 클라우드 환경을 고려하여 설계 -> 유연성 중요

### Outer/Inner 아키텍처
+ Outer: MSA가 운영되는 환경을 정의하는 과정
+ Inner: 실제로 비즈니스가 실행되는 각각의 MSA 내 구조 정의

## 인프라영역
+ 인프라로서의 서브스: IaaS
+ 플랫폼으로서의 서비스: Paas

## API Gateway
> 다양한 클라이언트가 개별 서비스에 액세스하기 위해서는 단일 진입점을 만들어 놓으면 여러모로 효율적

## 12-Factor
> 클라우드 네이티브 애플리케이션을 만들기 위한 체크 리스트
+ 클라우드에서 돌아갈 애플리케이션은 하드웨어나 컨테이너에 종속된 정보를 가지고 있으면 안된다 <- 플랫폼이 변경되었을 때 쉽게 이동하기가 힘듦(DB 연결 정보, 리소스 정보 ,호스트 명)

## Circuit Breaker
> 상황에 따라 서비스를 동적으로 증가시켜 과부하나 오류 상황에서도 지속 가능한 서비스가 가능하도록 관리 -> 실시간으로 관리되어 기각화하고 모니터링
+ 네트워크/서비스 장애가 다른 서비스로 전이되지 않도록 하는 방법
+ 연속 실패 횟수가 임계값을 초과하면 회로 차단기가 작동
+ 시간 초과 기간 동안 원격 서비스를 호출하련느 모든 시도가 즉시 실패 됨

## 3주차

## Application Architecture
> Web서버 Application서버 처리 영역 -> Application Architecture 영역
+ 외부 Architecture: Architecture를 이루는 구성요소의 관계를 설명
+ 내부 Architecture: Application의 내부 구조를 정의하는 활동

## Spring의 등장
+ POJO(Plain Old Java Object) 컨테이너 -> 로직을 순수하게 표현하는 것을 중요시 함
+ 프레임워크에 의존하지 않는 일반 Object 주기 관리
+ Object간의 의존 관계
### POJO
+ 비즈니스를 개체 모델로 표현
+ 기술에 의존적인 부분들을 분리하려고 노력함(Transaction 처리 및 에러, 로깅 처리, 데이터 처리) -> 의존관계들을 분리하기 위해 Spring에서는 AOP나 DI 기술을 활용

## Tier vs Layer 구분
### Tier
+ 물리층: 물리적인 장비, 서버 컴퓨터, 

+ 클라이언트 층(PC,스마트폰) - 중간층(Application 서버) - EIS층(데이터베이스, 레거시 시스템)
### Layer
> 설계자들이 복잡한 시스템을 분리 할 때 흔히 사용하는 패턴 중 하나
+ 논리층: Tier 내부의 논리적인 분할
+ 클라이언트 층 - 중간(Presentation, Business Logic, Data Access Layer) - EIS층
+ 상위는 하위를 호출함
+ 하위의 여러 Layer를 알 필요 없이 바로 밑에 근접한 Layer를 활용함
+ 다양한 서비스를 이용함

## Layered Architecture
+  각 Layer의 표준화, 각 Layer의 모듈화
1. 상의 Layer가 하위 Layer의 변경에 영향을 받지 않게 함
2. 어플리케이션이 쉽게 변경되거나 확장될 수 있게 함

## Spring에서 일반적으로 사용된느 구조
1. Presentation Layer
+ 컨트롤러: 화면 표현 처리, 화면 전환 버튼을 눌렀을 때 이벤트 처리, 세션 관리 기능 제공
2. Business Logic Layer
+ 서비스: Presentation Lyaer의 컨트롤러에 의해 호출, 도메인 로직을 호출, 특정업무 처리 흐름 제어
+ 도메인: Business Logic 실행에 주요 개념 및 그 구체적인 로직을 담고 있음, Spring의 POJO 계층으로 구성
3. Data Access Layer
+ DAO: DAO(Data Access Object)라는 구성요소를 가짐, 서비스가 처리한 결과를 받아 데이터로 저장하는 역할 수행

## Layer 간의 호출 원칙
> 개발 효율성을 높임, 운영 시 쉽게 변경/확장 가능
1. 각 Layer는 높은 응집력을 갖춘 외부와 Layer 간의 낮은 결합도를 갖도록 설계
2. Layer 사이으 ㅣ호출은 인터페이스를 통해 호출하는것이 바람직함 -> 인터페이스를 하나 더 만드는 것이 번거로워 클래스를 이요하지 않기
 + 인터페이스 사용: Layer의 경계를 넘어서 들어오는 요청을 명확히 정의하겠다는것을 의미함
 3. 구현 클래스에 직접 의존하지 않음으로써 Object 사이에 약한 결합을 유지함

## Hexagonal Architecture
> 제일 하위에 존재하는 Data Accesscmddml DB를 교체한다면 BL층에 영향 없이 변경하기 힘듬. 이러한 단점을 해결하는 방안이 Hexagonal Architecture.

## BL 처리시
+ BL 처리영역: 어플리케이션에서 제일 중요한 영역 -> BL에 영향을 미치지 않는것이 가장 좋은 설계
    + 브라우저에 표현하는 기술
    + 데이터베이스에 저장하는 기술
+ BL 결과 처리 영역 -> 결과를 사용자에게 보여주는 부분 + 결과를 저장하는부분(기술의 변화에 많은 영향을 받는 부분)

## DIP(Dependency Inversion Principle) 의존관계의 역전 원칙
> 로버트 C.마틴: 객체지향 원칙의 5가지 원칙, [http://www.kmooc.kr/courses/course-v1:KAISTk+2018_K14+2020_K14_02/courseware/236506e314704c4e9468de809ad3d740/4f6371baa84949dd98890de7c89f8b34/?child=first]: 6:59
+ 의존하려면 ``잘 변경되지 않는`` 부분에 의존해야 한다는 원칙
+ 안정된 방향으로 의존하여 다른 패키지가 변경 받을 때 영향을 덜 받도록 하는 것
+ 다른 Layer에 가장 큰 영향을 줄 것 같은 위치에 있는 Layer의 의존 방향을 바꿔 적용함

## Transaction Script 패턴 구조
> 단순한 입출력 구조의 쉬운 업무 처리를 위한 마이크로 서비스 내부 구조로 활용하면 유용함

## Domain Model 패턴 구조
> 복잡한 비즈니스 로직을 정리 후 핵심 서비스로 활용하는 경우 효율적

## Data Access 층의 역할
### SQL Mapping
> 데이터 모델리을 통해 관계형 테이블 작성 후 BL을 처리할 때 유용함
+ BL Layer에 Transaction Script 패턴을 적용하는 경우 적합한 방식
+ 개발자가 직접 SQL 작성 -> 세밀한 SQL 컨트롤이 필요한 경우 유용함

### OR MApping
> 객체지향 중심, Domain Model의 Entityf 추출
1. BL에 필요한 Object가 무엇인지 먼저 고려함
2. 비즈니스를 처리하는 흐름 구현
3. 저장소 결정 및 Object에 Mapping하여 데이터를 처리
+ OR MApper가 SQL문을 자동으로 생성 -> 저장소를 다른 RDB 또는 No-SQL 저장소로 쉽게 변경하는 경우 유용함

## 4주차

### 동기식 호출(Sync 방식)
> 요청을 하면 바로 응답이 오는 방식
+ 호출을 받은 MSA 서비스에서 장애 발생시 연쇄적인 장애 발생

### 비동기식 호출
> 메시지를 보낸 다음 응답을 기다리지 않고 일을 처리
+ 동기식처럼 완결성을 보장할 수 없음
+ Kafka, RabbitMQ, 같은 메시지 브로커 사용
+ 통신하는 서비스들이 물리적으로 동일한 시스템에 위치할 필요 없음
+ 프로세스를 서로 공유할 필요 없음
+ 같은 시간 동시에 동작할 필요 없음

### SAGA패턴
> 각 서비스의 로컬 트랜잭션을 순차적으로 처리하는 패턴. 각 로컬 트랜잭션은 자신의 데이터베이스를 업데이트한 후 SAGA내에 있는 다음 로컬 트랜잭션을 트리거 하는 메시지 또는 이벤트를 게시하는 기법
### 보상 트랜잭션
> 어떤 서비스에서 트랜잭션 처리에 실패할 경우, 서비스의 앞선 다른 서비스에서 처리된 트랜잭션을 되돌리게 하는 트랜잭션
### Choreography SAGA 패턴
### Orchestrator SAGA 패턴

### CQRS 패턴 (Command Query Responsibility Segregation: 명령 조회 책임 분리
> 명령과 조회의 역할 분리, [http://www.kmooc.kr/courses/course-v1:KAISTk+2018_K14+2020_K14_02/courseware/c9952da89bea4493869521a73c7cad6d/cc3ef35ade524be98bb74b48cfa3ef96/?child=first] 2:54
+ 사용자의 비즈니스 요청: 시스템 상태를 변경하는 명령 < 시스템의 상태를 가져오는 조회
+ Create, Update, Delete 처리 수행 서비스(Java, RDB) <-> MQ <-> 조회 서비스(Node.js, MongoDb) (읽기만 Scale-Out가능)
+ 데이터 CUD시 시간적 텀이 있을 수 있지만 어느 시점이 되면 결과적으로 일치함 -> 결과적 일관성(Eventual Consistency) 
### 이벤트 소싱
> 모든 쓰기를 이벤트로 전환해서 별도의 이벤트 스트림으로 스트림 저장소에 저장하는 방식
### 이벤트 스트림 저장소
+ 추가만 가능 하여 계속 이벤트를 쌓이게 만들고, 필요한 데이터를 구체화시키는 시점에서는 그때까지 축적된 데이터를 바탕으로 작성
+ 각각의 이벤트는 딱 한 가지 액티비티에만 집중하게 되어 아무리 복잡한 BL이라 하더라도 굉장히 간단하게 만들 수 있음

## 도메인 주도 설계(Domain Driven Design)
> 에릭 에반스
+ 이벤트 주도 설계: MSA의 관계를 느슨하게 만드는 중요한 기법
+ 이벤트 주도 MSA의 구조: 시스템 운영 방식 및 데이터, 서비스 간의 상호작용 파악이 중요함
+ 비슷한 비즈니스 기능과 데이터가 응집성 있게 하나의 서비스로 도출하는 것이 중요함

## 5주차

## 도메인 주도 설계
> 도메인 주도 설계의 설계는 비즈니스 상 전략적으로 중요한 것들을 찾아서 이를 나누고, 필요에 따라 분할 또는 통합해서 마이크로서비스를 식별하는 전략적 설계와 전략적 설계를 통해 식별된 마이크로서비스를 정제하고 확정해서 비즈니스의 고유한 활동을 모델링하는 전술적 설계로 구성
+ 도메인: 비즈니스, 복잡한 현실 세계의 문제
+ 개발자들도 분석과 설계자와 함께 회의 참석
+ 코드 구현에 앞서 도메인과 도메인 모델의 완전한 이해 강조
### 전략적 설계
> 마이크로서비스를 식별하는 역할
1. 명확히 식별된 Bounded Context 내부를 모델링하기 위한 유비쿼터스 언어 정의(유비쿼터스 언어: 소프트웨어 개발팀의 언어)
2. 이 공통의 언어를 활용해서 비즈니스를 분석하고 핵심이 되는 개념을 식별
3. 식별된 개념들을 분석해서 Bounded Context를 설계
4. 식별된 Bounded Context 간의 매핑 관계를 정의해서 Context map 작성
5. Bounded Conext로의 분할에 따른 효과를 분석해서 서비스의 분할 또는 통합을 검토 -> 후보 마이크로서비스 도출
6. 도출된 마이크로서비스 -> 전술적 설계 -> 최종 코드로 구현

### 전술적 설계
> 식별된 마이크로서비스의 내부구조 상세 정의, 비즈니스의 고유한 활동 모델링

### 모듈
> 도메인 개체를 담는 Container의 역할을 수행하는 것
### 도메인 모델
> 비즈니스의 핵심 개념을 도메인 객체로 표현 한 것(Uml Diagram 형태)
### 바운디드 컨텍스트
> 도메인의 주요 개념 정의, 도메인 간의 경계
### 유비쿼터스 언어
> Customer를 Accounting Context에서는 Customer가 Payer로, Order Context에서는 Customer가 Receiver로 정의돼서 사용

## Context Mapping
> 두 Bounded Context가 갖고 있는 각각의 유비쿼터스 언어 사이의 통역, 번역을 의미
+ Bounded Context 사이의 관계를 찾아 매핑할 때 두 Bounded Context 사이의 선이 어떤 종류의 관계인지를 찾는 것이 매우 중요합니다.
+ Context 매핑은 파트너십, 공유커널, 고객 공급자, 준수자, 충돌방지계층, 공개 호스트 서비스, 공표된 언어, 매핑을 하지 않는 것까지 총 8가지

+ 공유커널(Shared Kernel): 바운디드 컨텍스트 사이에 공통적인 모델을 공유하는 관계
+ 고객공급자 유형(Customer-Supplier): 고객이 원하는 것을 공급자가 제공해 주는 관계

## 6주차

### 이벤트 스토밍
> 마이크로서비스를 도출하기 위한 시스템 안의 이벤트를 이해하는 도메인 전문가와 개발자들의 브레인스토밍 활동
1. 도메인의 이벤트 찾기
    + 흐름의 순서대로 나열
    + 찾는 과정에서 문제점이나 명확하지 않은 것을 발견하면 모델링 공간에 표시
2. 커맨드 정의 및 커맨드를 동작하게 하는 특정한 사용자나 역할을 식별
3. 도메인을 여러개의 서브도메인으로 분할
4. 바운디드 콘택스트 식별

### 핫 스팟(Hot Spot)
> 질문, 가정, 경고 의견 수렴이 필요한 시점 ex) 구매할땐 어떤 정보가 필요한가? 신용카드 결제 프로세스를 연계하기 위해서는 더 많은 정보가 필요한 것이 아닌가 ? 등

### 커맨드(Command)
> 각 도메인 이벤트를 동작하게 하는 커맨드를 찾는 행동

### 정책(Policy)
> 사용자로 인해 동작하는 커맨드, 이 커맨드에 따라 시스템이 어떤 도메인 에벤트를 동작시키는지에 대한 가정이나 특정 사례, 기준 등을 정할때 사용

### 마이크서비스 매핑
> 마이크로서비스 간 연관관계를 식별하는 행동

## 7주차

### 헥사고날 아키텍처
> 이 헥사고날 아키텍처는 기능 요구사항에 따라 애플리케이션의 내부, 즉 도메인 모델을 설계하고, UI, 데이터베이스 등 기술과 도메인 모델을 분리하는 것              
고유한 비즈니스를 구현한 도메인과 기술의 분리는 다양하고 빠르게 바뀌는 UI, 데이터베이스 등의 기술의 변화에서 도메인을 격리시켜 보호할 수 있으며, UI, 데이터베이스 등 기술의 변경, 대체가 용이해짐

+ Client의 요청은 REST API 호출을 통한 Service Interface를 통해 도메인 모듈 내부로 전달
+ 어댑터를 통해 다른 마이크로서비스와의 연계나 메시지 전달 또는 데이터베이스와의 연계

### Entity
> ex) 주문, 상품
+ 도메인 모델 내의 객체
+ 고유 식별자를 가짐
+ 자신의 수명주기를 가짐
+ 속성이 아니라, 연속성 식별성에 의해 정의됨

### 값 객체
> ex) 주소, 금액
+ 사물의 속성을 기술하는 객체
+ 보통 식별자 없음
+ 읽기 전용 객체

### 표준 타입
> ex) 회원 유형: Gold, Silver
+ 대상의 타입을 나타내는 서술적 객체