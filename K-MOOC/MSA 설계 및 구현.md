# MSA 설계 및 구현

## 1주차

### 민첩한 비즈니스를 위해 필요한 시스템의 조건
+ Amazon, Netflix 같은 기업 -> 기존 서비스 + 온라인 기술 = 새로운 서비스 창출, 끊임없는 비즈니스 변화를 통한 새로운 가치 창출 
+ 고객에게빠른 서비스 제공, 피드백 기반의 서비스 개선 및 런칭 -> 시스템 배포 주기와 같이 시스템도 비즈 변화에 빠른 대응 조건 갖춰야함
+ 타임 세일 서비스 시작 -> 과도한 트랙픽 -> Scale Up필요 -> 전체 서비스 Scale Up 불필요 -> 타임 세일 서비스만 Scale Up 가능 하다면 효율적 -> MSA
+ 인프라가 가변적으로 쉽게 변경되는 클라우드 환경 -> 수평 확장을 위한 가장 효율적인 시스템 유형 -> MSA
+ 기업의 민첩한 비즈니스 대응을 위해서 MSA 기반의 시스템이 필요 -> 클라우드 네이티브 어플리케이션

### 마이크로서비스 개념과 모노리식 시스템과의 비교
+ 서로 다른 언어와 데이터 저장기술 사용 가능 -> 폴리그랏(Polyglot): 인터페이스 만족 시 서비스 안의 기술은 자율적으로 선택할 수 있음

### MSA가 주는 주요 특징
+ 비즈니스 역량 기반 팀
+ 프로젝트가 아니라 제품
    + Agile 개발 방식
+ 분권 거버넌스
+ 서비스를 통한 컴포넌트 화
+ 똑똑한 끝지점 단순한 파이프
+ 실패를 위한 설계
    + 실패를 감지하고 대응하기 위한 실시간 모니터링 체계 필요
    + 서킷 브레이크 패턴 -> 각각의 서비스를 모니터링하고 있다가 하나의 서비스가 다운되거나 실패되면 이를 호출하는 서비스의 연계를 차단하고 이에 적절한 대응을 하기 위해 만드는 것
+ 진화하는 설계
+ 분권 데이터 관리
    + 데이터 일관성 문제: 주문과 배송 같이 동시적 Transaction 발생시 문제
    + Eventual Transaction: 특정 시점에 불일치 했던 데이터가 결국에는 일관성을 확보
    + 보통 Event Queue를 써서 해결
+ 인프라 자동화
    + Smart Endpoints and Dump Pipes 선호
        + Domain Logic은 서비스 속에서 높은 응집성 유지 -> 각각의 서비스 연결은 느슨함
        + Rest와 같은 단순한 도구 선호

## 2주차
### 소프트웨어 아키텍처
+ 고려사항: 성능, 가용성, 보안, 유지보수성, 확장성
+ MSA -> 클라우드 환경을 고려하여 설계 -> 유연성 중요

### Outer/Inner 아키텍처
+ Outer: MSA가 운영되는 환경을 정의하는 과정
+ Inner: 실제로 비즈니스가 실행되는 각각의 MSA 내 구조 정의

## 인프라영역
+ 인프라로서의 서브스: IaaS
+ 플랫폼으로서의 서비스: Paas

## API Gateway
> 다양한 클라이언트가 개별 서비스에 액세스하기 위해서는 단일 진입점을 만들어 놓으면 여러모로 효율적

## 12-Factor
> 클라우드 네이티브 애플리케이션을 만들기 위한 체크 리스트
+ 클라우드에서 돌아갈 애플리케이션은 하드웨어나 컨테이너에 종속된 정보를 가지고 있으면 안된다 <- 플랫폼이 변경되었을 때 쉽게 이동하기가 힘듦(DB 연결 정보, 리소스 정보 ,호스트 명)

## Circuit Breaker
> 상황에 따라 서비스를 동적으로 증가시켜 과부하나 오류 상황에서도 지속 가능한 서비스가 가능하도록 관리 -> 실시간으로 관리되어 기각화하고 모니터링
+ 네트워크/서비스 장애가 다른 서비스로 전이되지 않도록 하는 방법
+ 연속 실패 횟수가 임계값을 초과하면 회로 차단기가 작동
+ 시간 초과 기간 동안 원격 서비스를 호출하련느 모든 시도가 즉시 실패 됨

## 3주차

## Application Architecture
> Web서버 Application서버 처리 영역 -> Application Architecture 영역
+ 외부 Architecture: Architecture를 이루는 구성요소의 관계를 설명
+ 내부 Architecture: Application의 내부 구조를 정의하는 활동

## Spring의 등장
+ POJO(Plain Old Java Object) 컨테이너 -> 로직을 순수하게 표현하는 것을 중요시 함
+ 프레임워크에 의존하지 않는 일반 Object 주기 관리
+ Object간의 의존 관계
### POJO
+ 비즈니스를 개체 모델로 표현
+ 기술에 의존적인 부분들을 분리하려고 노력함(Transaction 처리 및 에러, 로깅 처리, 데이터 처리) -> 의존관계들을 분리하기 위해 Spring에서는 AOP나 DI 기술을 활용

